package lesson_30;

public class Lesson30 {
    // Введение в Анализ сложности алгоритмов


    /*
    Алгоритм - последовательность шагов, которая представляет из себя исключительно вычесление и не учитывает
    особенности реализации "компьютерного железа" на котором она запущена.
    Анализ сложности дает возможность узнать как быстро будет работать программа когда она совершает вычисления
    на разных объемах входных данных
     */
    public static void main(String[] args) {
        drawTriangle(5);
    }

    public int findMax(int[] ints, int n) {
        int max = ints[0]; // 2 действия  ( найти и присвоить )
        // 2 инструкции до запуска цикла - инициализация и проверка условия окончания цикла
        for (int i = 0; i < n; i++) {
            if (max < ints[i]) { // 2 действия, которые происходят всегда - поиск в массиве и сравнение
                max = ints[i];
            }
        }
        return max;
    }

    // f(n) = 4 + 2n // необходимое алгаритму количество инструкций для цикла for с пустым телом

    //В теории алгоритмов рассматриваются наихудшин сценарии, т.е. в нашем случае массив, упорядоченныей по
    //возрастанию и max перезаписывается при каждой итерации

    //1,2,3,4
    //4,3,2,1

    //f(n) = 4 + 2n +4n = 4 + 6n
    //когда значение n сильно возрастает, константы не важны, поэтому 4 отбрасываем
    //f(n) = 6n

    // f(n)=n

    /*
    f(n) = 8n + 14 -> f(n) = n
    f(n) = 150     -> f(n) = 1

    f(n) = n^2 + 3n + 234 -> f(n) = n^2

    f(n) = n^3 + 5n + 112 -> f(n) = n^3

    f(n) = n + sqrt(n) -> f(n) = n





    написать метод выводящий на экран такой треугольник
    1
    12
    123
    1234
    12345
     */
    public static void drawTriangle(int n){

        for (int i = 0; i < n; i++) {
            System.out.print(i);
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i ; j++) {
                System.out.print(j);
            }
            System.out.println();
        }
    }

    // вложенный цикл дает поведение f(n) = n^2

    // Если в программе имеется несколько последовательных циклов, то поведение программы определяет самый медленный из них


    /*
    θ(f(n))
    θ(1) - алгоритм с константным временем
    θ(n) - линейный алгоритм
    θ(n^2) - квадратичный алгоритм

    Big O
    0(1) - алгоритм с константным временем . сложность такого алгоритма 1
    О(n) - сложность алгоритма О(n)
    О(n^2) - сложность алгоритма О(n^2)
    O(log n) - логарифмическая сложность

    2^x = 1024
    2^10 = 1024
    логарифм 1024 - это та степень, в которую нужно возвести 2 что бы получить 1024
    log(1024) = 10


    log(64) = 6
    2^6 = 64



    2^x = 4


    итерация    длина массива
    0           n
    1           n/2
    2           n/4  2^2
    3           n/8   2^3
    4           n/16  2^4
    5           n/32  2^5
    6           n/64  2^6
    i           n/2^i

    1= n/2^i
    2^i = n
    i = log(n)
     */
}
